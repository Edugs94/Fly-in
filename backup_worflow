================================================================================
                    FLUJO DE TRABAJO COMPLETO DE FLY-IN
                     Documentación Ultra Detallada
================================================================================

Este documento describe paso a paso cómo funciona el programa cuando se ejecuta
el comando: python main_solver.py maps/easy/01_linear_path.txt

El sistema resuelve el problema de enrutamiento de múltiples drones desde un
punto START hasta un punto END, respetando restricciones de capacidad en nodos
y aristas, utilizando un grafo expandido en el tiempo y el algoritmo de Dijkstra.

================================================================================
ÍNDICE
================================================================================
1. PUNTO DE ENTRADA: main_solver.py
2. FASE 1: PARSEO DEL ARCHIVO
3. FASE 2: ESTIMACIÓN DEL TIEMPO MÁXIMO
4. FASE 3: CONSTRUCCIÓN DEL GRAFO TEMPORAL
5. FASE 4: RESOLUCIÓN CON DIJKSTRA
6. FASE 5: GENERACIÓN DEL OUTPUT
7. ESTRUCTURAS DE DATOS CLAVE

================================================================================
1. PUNTO DE ENTRADA: main_solver.py
================================================================================

Archivo: main_solver.py
Función: main()

DESCRIPCIÓN GENERAL:
-------------------
El archivo main_solver.py es el punto de entrada del programa. Cuando el usuario
ejecuta el comando, este archivo coordina todo el flujo de trabajo:

1. Parsea los argumentos de línea de comandos
2. Invoca al parser para leer el archivo de mapa
3. Verifica que existe un camino válido
4. Estima el tiempo máximo necesario
5. Construye el grafo temporal y resuelve con reintentos
6. Imprime el resultado en el formato requerido

CONSTANTES GLOBALES:
-------------------
- MAX_RETRIES = 20: Número máximo de intentos para encontrar solución
- TIME_INCREMENT = 3: Cantidad de turnos a añadir en cada reintento

FUNCIÓN main():
---------------
Parámetros: Ninguno (lee de sys.argv)
Retorno: None (imprime resultado o termina con error)

Paso 1: Validación de argumentos
    - Lee sys.argv para obtener el path del archivo de mapa
    - Si no hay argumentos, imprime mensaje de uso y sale con código 1

Paso 2: Instanciación del parser
    parser = FileParser()
    - Crea una nueva instancia de la clase FileParser
    - FileParser internamente inicializa un SimulationMap vacío
    - FileParser configura los procesadores para cada tipo de línea

Paso 3: Parseo del archivo
    simulation = parser.parse(map_file)
    - Llama al método parse() pasando el path del archivo
    - Retorna un objeto SimulationMap completamente poblado
    - Si hay errores de formato, el programa termina aquí

Paso 4: Verificación de camino existente
    if not has_path_to_end(simulation):
        print("ERROR: No path exists from START to END")
        sys.exit(1)
    - Usa BFS para verificar que existe al menos un camino
    - Si no hay camino posible, el programa termina con error

Paso 5: Estimación del tiempo máximo
    initial_max_time = estimate_max_time(simulation)
    - Calcula cuántos turnos necesitaremos como máximo
    - Fórmula: min_path_length + nb_drones

Paso 6: Resolución con reintentos
    solver, _ = solve_with_retry(simulation, initial_max_time)
    - Intenta resolver hasta MAX_RETRIES veces
    - Si falla, incrementa el tiempo y vuelve a intentar
    - Retorna el solver con todas las rutas calculadas

Paso 7: Output
    solver.print_simulation_output()
    - Imprime el resultado en formato requerido

FUNCIÓN solve_with_retry():
---------------------------
Parámetros:
    - simulation: SimulationMap con toda la configuración del mapa
    - initial_max_time: int con la estimación inicial de tiempo máximo

Retorno: Tupla (FlowSolver, int) con el solver y el tiempo usado

Funcionamiento:
    1. Inicializa max_time con initial_max_time
    2. Itera hasta MAX_RETRIES veces:
        a. Construye un TimeGraph con el max_time actual
        b. Llama a time_graph.build_graph() para poblar el grafo
        c. Crea un FlowSolver con el grafo
        d. Llama a solver.solve_all_drones() para encontrar rutas
        e. Si encontró rutas para todos los drones, retorna éxito
        f. Si no, incrementa max_time en TIME_INCREMENT
    3. Si agota los reintentos, lanza ValueError

================================================================================
2. FASE 1: PARSEO DEL ARCHIVO
================================================================================

Archivo: src/parser/file_parser.py
Clase: FileParser

DESCRIPCIÓN GENERAL:
-------------------
FileParser es responsable de leer un archivo de texto con el formato específico
del mapa y convertirlo en un objeto SimulationMap estructurado. Utiliza un
patrón de diseño basado en procesadores especializados para cada tipo de entidad.

CLASE FileParser:
-----------------

Constructor __init__():
    - Crea un SimulationMap vacío:
        self.simulation_map = SimulationMap(
            nb_drones=0,
            hubs={},
            connections={},
        )

    - Configura diccionario de procesadores:
        self.processors = {
            "hub": HubProcessor(NodeCategory.INTERMEDIATE),
            "start_hub": HubProcessor(NodeCategory.START),
            "end_hub": HubProcessor(NodeCategory.END),
            "connection": ConnectionProcessor(),
            "nb_drones": DroneProcessor(),
        }

    Cada procesador sabe cómo parsear un tipo específico de línea.

MÉTODO parse(filename: str) -> SimulationMap:
--------------------------------------------
Este es el método principal que coordina todo el parseo.

Paso 1: Abrir el archivo
    with open(filename, "r") as f:
    - Abre el archivo en modo lectura
    - Si el archivo no existe, captura OSError y termina

Paso 2: Iterar línea por línea
    for line_num, line in enumerate(f, start=1):
        line = line.strip()
    - enumerate() proporciona número de línea para mensajes de error
    - strip() elimina espacios y saltos de línea

Paso 3: Ignorar líneas vacías y comentarios
    if not line or line.startswith("#"):
        continue
    - Las líneas vacías se ignoran
    - Las líneas que empiezan con # son comentarios

Paso 4: Validar formato básico
    if ":" not in line:
        print(f"[ERROR] Line {line_num}: Missing ':' separator.")
        sys.exit(1)
    - Toda línea válida debe tener el formato "tipo: datos"

Paso 5: Extraer tipo y datos
    key, content = line.split(":", 1)
    key = key.strip().lower()
    data = content.lower().strip().split(" ", 3)

    Ejemplo: "Hub: waypoint1 10 20 [zone=priority]"
    - key = "hub"
    - data = ["waypoint1", "10", "20", "[zone=priority]"]

Paso 6: Seleccionar procesador
    processor = self.processors.get(key)
    - Busca el procesador correspondiente al tipo
    - Si no existe, imprime error y termina

Paso 7: Procesar la línea
    processor.process(data, self.simulation_map)
    - Delega el procesamiento al procesador específico
    - El procesador modifica self.simulation_map directamente

Paso 8: Validaciones finales
    Después de procesar todas las líneas:

    a. Buscar START y END:
        for hub in self.simulation_map.hubs.values():
            if hub.category == NodeCategory.START:
                start_hub = hub
                start_hub.current_drones = self.simulation_map.nb_drones
            elif hub.category == NodeCategory.END:
                end_hub = hub

    b. Validar que existen:
        - Si no hay START: error y salir
        - Si no hay END: error y salir

    c. Validar capacidades:
        - START debe poder contener todos los drones
        - END debe poder contener todos los drones

    d. Retornar el mapa completo:
        return self.simulation_map

--------------------------------------------------------------------------------
PROCESADORES DE LÍNEA
--------------------------------------------------------------------------------

Archivo: src/parser/processors/drone_processor.py
Clase: DroneProcessor
---------------------
Procesa líneas del tipo: "nb_drones: 5"

MÉTODO _do_process(data: list[str], current_map: SimulationMap):
    - Valida que solo hay un valor numérico
    - Valida que el número es mayor que 0
    - Valida que no se ha definido antes
    - Asigna: current_map.nb_drones = int(data[0])

Archivo: src/parser/processors/hub_processor.py
Clase: HubProcessor
-------------------
Procesa líneas del tipo: "Hub: waypoint1 10 20 [zone=priority max_drones=3]"

CONSTANTES:
    ALLOWED_KEYS = {"zone", "color", "max_drones"}

CONSTRUCTOR __init__(category: NodeCategory):
    - Recibe la categoría del hub (START, END, INTERMEDIATE)
    - La categoría determina el rol del hub en la simulación

MÉTODO _do_process(data: list[str], current_map: SimulationMap):
    Paso 1: Validar que nb_drones está definido
    Paso 2: Validar que hay al menos 3 parámetros (nombre, x, y)
    Paso 3: Extraer nombre y verificar que no está duplicado
    Paso 4: Verificar que coordenadas no están duplicadas
    Paso 5: Parsear parámetros opcionales si existen
        - Formato: [key1=value1 key2=value2]
        - Claves permitidas: zone, color, max_drones
        - zone puede ser: normal, blocked, restricted, priority
    Paso 6: Crear objeto Hub con pydantic y añadirlo al mapa

Archivo: src/parser/processors/connection_processor.py
Clase: ConnectionProcessor
--------------------------
Procesa líneas del tipo: "Connection: waypoint1-waypoint2 [max_link_capacity=2]"

CONSTANTES:
    ALLOWED_KEYS = {"max_link_capacity"}

MÉTODO _do_process(data: list[str], current_map: SimulationMap):
    Paso 1: Validar que nb_drones está definido
    Paso 2: Parsear el formato "source-target"
        - Exactamente un guión
        - Source y target diferentes
    Paso 3: Verificar que ambos hubs existen
    Paso 4: Verificar que la conexión no está duplicada
    Paso 5: Parsear parámetros opcionales
        - max_link_capacity: capacidad máxima de drones simultáneos
    Paso 6: Crear objeto Connection y añadirlo a connections
        - connections es un dict de dicts: connections[source][target]

--------------------------------------------------------------------------------
ESQUEMAS DE DATOS
--------------------------------------------------------------------------------

Archivo: src/schemas/simulation_map.py
Clase: SimulationMap (hereda de pydantic.BaseModel)
---------------------------------------------------
Representa el estado completo del mapa parseado.

Atributos:
    - nb_drones: int - Número total de drones a enrutar
    - hubs: dict[str, Hub] - Diccionario de hubs indexado por nombre
    - connections: dict[str, dict[str, Connection]] - Conexiones bidimensionales

Archivo: src/schemas/hubs.py
Clase: Hub (hereda de MapEntity/BaseModel)
------------------------------------------
Representa un punto/nodo en el mapa.

Atributos:
    - name: str - Identificador único del hub
    - category: NodeCategory - Rol: START, END, INTERMEDIATE
    - type: ZoneType - Tipo de zona (legacy, usar zone)
    - zone: ZoneType - Tipo: NORMAL, BLOCKED, RESTRICTED, PRIORITY
    - x: int - Coordenada X en el mapa
    - y: int - Coordenada Y en el mapa
    - max_drones: int - Capacidad máxima (default=1)
    - current_drones: int - Drones actualmente en el hub
    - color: str | None - Color opcional para visualización

Archivo: src/schemas/connection.py
Clase: Connection (hereda de MapEntity/BaseModel)
-------------------------------------------------
Representa una arista direccional entre dos hubs.

Atributos:
    - source: str - Nombre del hub origen
    - target: str - Nombre del hub destino
    - max_link_capacity: int - Drones simultáneos permitidos (default=1)
    - current_drones: int - Drones actualmente en tránsito
    - cost: int - Costo base del viaje

Archivo: src/schemas/definitions.py
Enums: ZoneType y NodeCategory
------------------------------
ZoneType define tipos de zonas:
    - NORMAL: Sin restricciones
    - BLOCKED: Intransitable
    - RESTRICTED: Requiere 2 turnos para atravesar
    - PRIORITY: Preferido en la selección de rutas

NodeCategory define roles de nodos:
    - START: Punto de partida de todos los drones
    - END: Punto de llegada/objetivo
    - INTERMEDIATE: Waypoint intermedio

================================================================================
3. FASE 2: ESTIMACIÓN DEL TIEMPO MÁXIMO
================================================================================

Archivo: src/solver/time_estimator.py

DESCRIPCIÓN GENERAL:
-------------------
Este módulo contiene funciones para estimar cuántos turnos necesitará la
simulación. El grafo temporal necesita un límite de tiempo para construirse,
y estas funciones calculan una estimación razonable.

FUNCIÓN has_path_to_end(simulation: SimulationMap) -> bool:
----------------------------------------------------------
Verifica si existe al menos un camino desde START hasta END.

Propósito:
    Detección temprana de mapas imposibles antes de gastar recursos
    construyendo el grafo temporal.

Algoritmo: BFS (Breadth-First Search) en el grafo estático

Paso 1: Identificar hubs de inicio y fin
    start_hubs = [hubs con categoría START y zona != BLOCKED]
    end_hubs = {hubs con categoría END y zona != BLOCKED}

Paso 2: Si no hay start o end válidos, retornar False

Paso 3: BFS desde el START
    visited = set()
    queue = deque([start_hub])

    while queue:
        current = queue.popleft()

        if current in end_hubs:
            return True  # ¡Encontramos camino!

        if current in visited:
            continue
        visited.add(current)

        # Añadir vecinos no bloqueados
        for neighbor in connections[current]:
            if neighbor not in visited and not blocked:
                queue.append(neighbor)

    return False  # No hay camino

FUNCIÓN estimate_min_path_length(simulation: SimulationMap) -> int:
------------------------------------------------------------------
Calcula la longitud mínima del camino más corto de START a END.

Propósito:
    Conocer el mínimo absoluto de turnos necesarios para que un drone
    llegue al destino, considerando que zonas RESTRICTED cuestan 2 turnos.

Algoritmo: BFS modificado con peso de aristas

Diferencia con has_path_to_end():
    - Lleva cuenta de la distancia acumulada
    - Zonas RESTRICTED suman 2 al costo, otras suman 1

Paso 1: Inicializar
    visited = {}  # hub -> distancia mínima para llegar
    queue = deque([(start_hub, 0)])

Paso 2: BFS con distancias
    while queue:
        current, distance = queue.popleft()

        if current in end_hubs:
            return distance  # Distancia mínima encontrada

        if current in visited:
            continue
        visited[current] = distance

        for neighbor in connections[current]:
            if neighbor not in visited and not blocked:
                cost = 2 if neighbor.zone == RESTRICTED else 1
                queue.append((neighbor, distance + cost))

    return -1  # No hay camino

FUNCIÓN estimate_max_time(simulation: SimulationMap) -> int:
-----------------------------------------------------------
Estima el tiempo máximo que necesitará la simulación completa.

Propósito:
    Proporcionar un límite de tiempo razonable para construir el grafo
    temporal. Debe ser suficiente para todos los drones considerando
    colas y congestión.

Fórmula:
    estimated_time = min_path_length + nb_drones + 5

Lógica:
    - min_path_length: Tiempo mínimo para UN drone sin congestión
    - nb_drones: Margen para colas en cuellos de botella
    - 5: Buffer de seguridad adicional

Ejemplo:
    min_path = 4 turnos
    nb_drones = 10
    estimated_time = 4 + 10 + 5 = 19 turnos

Si la estimación es insuficiente, solve_with_retry() incrementará
automáticamente el tiempo y volverá a intentar.

================================================================================
4. FASE 3: CONSTRUCCIÓN DEL GRAFO TEMPORAL
================================================================================

Archivo: src/solver/time_graph.py
Clase: TimeGraph

DESCRIPCIÓN GENERAL:
-------------------
TimeGraph implementa un "Time-Expanded Graph" (Grafo Expandido en el Tiempo).
Este es un concepto fundamental del sistema.

¿QUÉ ES UN GRAFO EXPANDIDO EN EL TIEMPO?
----------------------------------------
En un grafo normal, cada nodo representa una ubicación física.
En un grafo expandido en el tiempo, cada nodo representa una ubicación
física EN UN MOMENTO ESPECÍFICO DEL TIEMPO.

Ejemplo:
    Grafo normal: [A] ---> [B] ---> [C]

    Grafo temporal (max_time=3):
        t=0: [A,0] ---> [B,1] ---> [C,2]
        t=1: [A,1] ---> [B,2] ---> [C,3]
        t=2: [A,2] ---> [B,3]
        t=3: [A,3]

        También hay "wait edges" (aristas de espera):
        [A,0] ---> [A,1] ---> [A,2] ---> [A,3]
        [B,1] ---> [B,2] ---> [B,3]
        etc.

Esto permite modelar:
    1. El tiempo de viaje entre nodos
    2. La espera en un nodo
    3. Conflictos temporales (dos drones en el mismo lugar/momento)

CLASE TimeGraph:
----------------

CONSTRUCTOR __init__(simulation: SimulationMap, max_time: int):
    Parámetros:
        - simulation: El mapa parseado con hubs y conexiones
        - max_time: Límite temporal del grafo

    Inicialización:
        self.max_time = max_time
        self.nodes: Dict[Tuple[str, int], TimeNode] = {}
        self.edges: List[TimeEdge] = []
        self.simulation: SimulationMap = simulation

    - nodes: Diccionario indexado por (nombre_hub, tiempo)
    - edges: Lista plana de todas las aristas temporales

MÉTODO _add_node(hub: Hub, turn: int) -> None:
---------------------------------------------
Crea un TimeNode si no existe ya.

Paso 1: Crear clave única
    key = (hub.name, turn)  # Ej: ("waypoint1", 3)

Paso 2: Verificar condiciones
    - Si la clave ya existe, no hacer nada
    - Si el hub está BLOCKED, no crear nodo

Paso 3: Calcular drones iniciales
    initial_drones = 0
    if hub.category == NodeCategory.START and turn == 0:
        initial_drones = self.simulation.nb_drones

    El nodo START en t=0 comienza con todos los drones.

Paso 4: Crear y almacenar
    self.nodes[key] = TimeNode(hub, turn, initial_drones)

MÉTODO _add_edge(source: TimeNode, target: TimeNode, max_capacity: int):
-----------------------------------------------------------------------
Crea una arista temporal entre dos TimeNodes.

    new_edge = TimeEdge(source, target, max_capacity)
    self.edges.append(new_edge)

La arista conecta un nodo en tiempo T1 con otro en tiempo T2.
max_capacity limita cuántos drones pueden usar la arista simultáneamente.

MÉTODO _get_travel_time(target_hub: Hub) -> int:
------------------------------------------------
Determina cuántos turnos tarda llegar a un hub.

    if target_hub.zone == ZoneType.RESTRICTED:
        return 2  # Zonas restringidas tardan 2 turnos
    return 1  # Todo lo demás tarda 1 turno

MÉTODO build_graph() -> None:
-----------------------------
Construye el grafo temporal completo. Este es el método principal.

Paso 1: Filtrar hubs válidos
    valid_hubs = {
        hub.name: hub
        for hub in hubs
        if hub.zone != ZoneType.BLOCKED
    }

    Los hubs BLOCKED se excluyen completamente.

Paso 2: Crear todos los nodos
    for t in range(self.max_time + 1):
        for hub in valid_hubs.values():
            self._add_node(hub, t)

    Esto crea la "rejilla" de nodos temporales.
    Para max_time=10 y 5 hubs, crea 11 * 5 = 55 nodos.

Paso 3: Crear aristas de movimiento
    for t in range(self.max_time):
        for source_name, targets in connections.items():
            for target_name, connection in targets.items():
                # Saltar si origen o destino no son válidos
                if source_name not in valid_hubs:
                    continue
                if target_name not in valid_hubs:
                    continue

                # Calcular tiempo de llegada
                target_hub = valid_hubs[target_name]
                travel_time = self._get_travel_time(target_hub)
                arrival_time = t + travel_time

                # Saltar si la llegada excede max_time
                if arrival_time > self.max_time:
                    continue

                # Obtener nodos origen y destino
                source_node = self.nodes.get((source_name, t))
                target_node = self.nodes.get((target_name, arrival_time))

                # Crear la arista
                if source_node and target_node:
                    self._add_edge(
                        source_node,
                        target_node,
                        connection.max_link_capacity
                    )

Paso 4: Crear aristas de espera (wait edges)
    for hub in valid_hubs.values():
        wait_source = self.nodes.get((hub.name, t))
        wait_target = self.nodes.get((hub.name, t + 1))

        if wait_source and wait_target:
            self._add_edge(
                wait_source,
                wait_target,
                wait_source.hub.max_drones  # IMPORTANTE
            )

    Las aristas de espera conectan el mismo hub en tiempos consecutivos.
    Su capacidad es la capacidad del hub (max_drones), NO 1.
    Esto permite que múltiples drones esperen en el mismo hub.

--------------------------------------------------------------------------------
MODELOS DE DATOS DEL GRAFO TEMPORAL
--------------------------------------------------------------------------------

Archivo: src/solver/models.py

CLASE TimeNode:
---------------
Representa un hub físico en un momento específico del tiempo.

CONSTRUCTOR __init__(hub: Hub, time: int, initial_drones: int = 0):
    self.hub: Hub = hub                    # Referencia al hub físico
    self.time: int = time                  # Instante temporal
    self.is_priority: bool = (hub.zone == ZoneType.PRIORITY)
    self.is_end: bool = (hub.category == NodeCategory.END)
    self.current_drones: int = initial_drones  # Drones en este nodo

MÉTODO can_enter() -> bool:
    Verifica si hay espacio para un drone más.
    return self.current_drones < self.hub.max_drones

MÉTODO add_drone() -> None:
    Registra un drone entrando al nodo.
    self.current_drones += 1

MÉTODOS __eq__ y __hash__:
    Dos TimeNodes son iguales si tienen mismo hub.name y mismo time.
    Esto permite usarlos como claves de diccionario.

CLASE TimeEdge:
---------------
Representa una conexión entre dos TimeNodes.

CONSTRUCTOR __init__(source: TimeNode, target: TimeNode, max_capacity: int):
    self.source = source           # Nodo origen
    self.target = target           # Nodo destino
    self.duration = target.time - source.time  # Duración del viaje
    self.max_capacity = max_capacity           # Capacidad máxima

MÉTODO is_traversable(tracker: EdgeTracker) -> bool:
    Verifica si la arista tiene capacidad disponible para todo el viaje.

    for turn in range(self.duration):
        current_drones = tracker.get_current_drones(
            self, self.source.time + turn
        )
        if current_drones >= self.max_capacity:
            return False
    return True

    Para aristas de duración 2 (zonas RESTRICTED), verifica AMBOS turnos.

MÉTODO use_edge(tracker: EdgeTracker) -> None:
    Registra que un drone está usando esta arista.

    for turn in range(self.duration):
        tracker.add_drone(self, self.source.time + turn)

CLASE EdgeTracker:
------------------
Gestiona la ocupación de aristas a través del tiempo.

ESTRUCTURA INTERNA:
    self.edge_drones: dict[tuple[TimeEdge, int], int] = defaultdict(int)

    La clave es (arista, turno), el valor es el número de drones.

MÉTODO get_current_drones(edge: TimeEdge, time: int) -> int:
    Retorna cuántos drones están usando esta arista en este turno.
    return self.edge_drones[(edge, time)]

MÉTODO add_drone(edge: TimeEdge, time: int) -> None:
    Incrementa el contador de drones en la arista/turno.
    self.edge_drones[(edge, time)] += 1

================================================================================
5. FASE 4: RESOLUCIÓN CON DIJKSTRA
================================================================================

Archivo: src/solver/flow_solver.py
Clase: FlowSolver

DESCRIPCIÓN GENERAL:
-------------------
FlowSolver resuelve el problema de enrutamiento de múltiples drones.
Usa el algoritmo de Dijkstra modificado para encontrar el camino óptimo
para cada drone, respetando las restricciones de capacidad.

ESTRATEGIA:
-----------
Los drones se procesan SECUENCIALMENTE (uno por uno).
Cuando un drone reserva un camino, ese camino queda "ocupado" y los
siguientes drones deben buscar alternativas o esperar.

CLASE FlowSolver:
-----------------

CONSTRUCTOR __init__(time_graph: TimeGraph, nb_drones: int):
    self.time_graph = time_graph
    self.nb_drones = nb_drones
    self.tracker = EdgeTracker()  # Rastrea ocupación de aristas
    self.adjacency = self._build_adjacency()  # Lista de adyacencia
    self.drone_paths: Dict[int, List[TimeNode]] = {}  # Rutas encontradas

MÉTODO _build_adjacency() -> Dict[TimeNode, List[TimeEdge]]:
-----------------------------------------------------------
Construye una lista de adyacencia para búsquedas eficientes.

    adjacency: Dict[TimeNode, List[TimeEdge]] = {
        node: [] for node in self.time_graph.nodes.values()
    }
    for edge in self.time_graph.edges:
        if edge.source in adjacency:
            adjacency[edge.source].append(edge)
    return adjacency

Resultado: Para cada nodo, una lista de aristas salientes.

MÉTODO find_start_nodes() -> List[TimeNode]:
--------------------------------------------
Encuentra todos los nodos START en tiempo 0.

    return [
        node
        for node in self.time_graph.nodes.values()
        if node.time == 0 and node.hub.category == NodeCategory.START
    ]

Normalmente hay un solo nodo START, pero la implementación soporta varios.

MÉTODO solve_all_drones() -> Dict[int, List[TimeNode]]:
-------------------------------------------------------
Método principal que coordina la resolución de todos los drones.

    start_nodes = self.find_start_nodes()
    start_node = start_nodes[0]  # Usamos el primer START

    for drone_id in range(1, self.nb_drones + 1):
        # Encontrar ruta para este drone
        path = self.solve_for_drone(drone_id, start_node)

        if path:
            # Guardar la ruta
            self.drone_paths[drone_id] = path
            # Reservar recursos (nodos y aristas)
            self._reserve_path(path)
        else:
            print(f"Drone {drone_id}: No valid path found!")

    return self.drone_paths

Orden de procesamiento:
    Drone 1, Drone 2, Drone 3, ... Drone N
    Cada drone tiene "prioridad" sobre los siguientes porque reserva
    primero los recursos.

MÉTODO solve_for_drone(drone_id: int, start_node: TimeNode):
------------------------------------------------------------
Encuentra el mejor camino para UN drone usando Dijkstra modificado.

CRITERIO DE OPTIMIZACIÓN:
    Tupla (turns, -priorities) donde:
    - turns: Tiempo total para llegar (MINIMIZAR)
    - priorities: Zonas prioritarias visitadas (MAXIMIZAR)

    Al usar -priorities, el heap de Python (min-heap) prefiere
    caminos con más prioridades cuando el tiempo es igual.

ESTRUCTURAS DE DATOS:
    best: Dict[TimeNode, Tuple[int, int]]
        Mejor (distancia, prioridades) conocida para cada nodo

    parents: Dict[TimeNode, Optional[TimeNode]]
        Nodo padre en el camino óptimo (para reconstruir ruta)

    pq: List[Tuple[Tuple[int, int], int, TimeNode]]
        Cola de prioridad: ((distancia, -prioridades), id_unico, nodo)

    visited: set[TimeNode]
        Nodos ya procesados

ALGORITMO PASO A PASO:

Paso 1: Inicialización
    start_priority = 1 if start_node.hub.zone == ZoneType.PRIORITY else 0

    best = {start_node: (0, start_priority)}
    parents = {start_node: None}
    pq = [((0, -start_priority), id(start_node), start_node)]
    visited = set()

Paso 2: Bucle principal
    while pq:
        # Extraer nodo con menor costo
        (current_dist, neg_priority), _, current_node = heapq.heappop(pq)
        current_priority = -neg_priority

        # Saltar si ya visitamos este nodo
        if current_node in visited:
            continue
        visited.add(current_node)

        # ¿Llegamos al END?
        if current_node.hub.category == NodeCategory.END:
            path = self._reconstruct_path(parents, current_node)
            return path

Paso 3: Explorar vecinos
        for edge in self.adjacency.get(current_node, []):
            neighbor = edge.target

            # Saltar nodos ya visitados
            if neighbor in visited:
                continue

            # Verificar capacidad de la arista
            if not edge.is_traversable(self.tracker):
                continue

            # Verificar capacidad del nodo destino
            is_start_at_zero = (
                neighbor.hub.category == NodeCategory.START
                and neighbor.time == 0
            )
            if not is_start_at_zero and not neighbor.can_enter():
                continue

            # Calcular nuevo costo
            new_dist = current_dist + edge.duration
            neighbor_priority = (
                1 if neighbor.hub.zone == ZoneType.PRIORITY else 0
            )
            new_priority = current_priority + neighbor_priority

            # Comparar con el mejor conocido
            current_best = best.get(neighbor)
            new_cost = (new_dist, -new_priority)
            best_cost = (
                (current_best[0], -current_best[1])
                if current_best
                else None
            )

            # Actualizar si es mejor
            if best_cost is None or new_cost < best_cost:
                best[neighbor] = (new_dist, new_priority)
                parents[neighbor] = current_node
                heapq.heappush(
                    pq,
                    (new_cost, id(neighbor), neighbor)
                )

Paso 4: Si no se encontró camino
    return None

EJEMPLO DE COMPARACIÓN DE COSTOS:
    Camino A: 5 turnos, 2 prioridades -> (5, -2)
    Camino B: 5 turnos, 1 prioridad  -> (5, -1)
    Camino C: 4 turnos, 0 prioridades -> (4, 0)

    Orden de preferencia: C < A < B
    (C es mejor porque 4 < 5, A es mejor que B porque -2 < -1)

MÉTODO _reconstruct_path(parents, end_node) -> List[TimeNode]:
--------------------------------------------------------------
Reconstruye el camino desde el inicio hasta el final.

    path = []
    current = end_node
    while current is not None:
        path.append(current)
        current = parents.get(current)
    path.reverse()
    return path

Resultado: Lista ordenada [start, ..., ..., end]

MÉTODO _reserve_path(path: List[TimeNode]) -> None:
---------------------------------------------------
Reserva todos los recursos usados por un camino.

Paso 1: Reservar aristas
    edges = self._get_path_edges(path)
    for edge in edges:
        edge.use_edge(self.tracker)

    Esto marca la arista como ocupada en los turnos correspondientes.

Paso 2: Reservar nodos
    for node in path:
        is_start_at_zero = (
            node.hub.category == NodeCategory.START and node.time == 0
        )
        if not is_start_at_zero:
            node.add_drone()

    Incrementa current_drones en cada nodo visitado.
    Excepción: El nodo START en t=0 ya tiene los drones contabilizados.

================================================================================
6. FASE 5: GENERACIÓN DEL OUTPUT
================================================================================

Archivo: src/solver/flow_solver.py
Métodos de output en FlowSolver

DESCRIPCIÓN GENERAL:
-------------------
Después de resolver las rutas, el sistema genera la salida en el formato
específico requerido: una línea por turno, con los movimientos de todos
los drones separados por espacios.

FORMATO DE SALIDA:
------------------
    D1-waypoint2 D2-waypoint1
    D1-end D2-waypoint2
    D2-end

Cada línea representa un turno.
Cada movimiento tiene formato: D<id>-<destino>
Para zonas RESTRICTED en tránsito: D<id>-<origen>-<destino>

MÉTODO get_simulation_output() -> List[str]:
--------------------------------------------
Genera la lista completa de líneas de salida.

Paso 1: Verificar que hay rutas
    if not self.drone_paths:
        return []

Paso 2: Calcular tiempo máximo
    max_time = max(
        path[-1].time for path in self.drone_paths.values() if path
    )

    El último nodo de cada path (el END) determina cuándo termina.

Paso 3: Iterar por cada turno
    output_lines: List[str] = []
    delivered: set[int] = set()  # Drones que ya llegaron al END

    for t in range(max_time):
        movements: List[str] = []

Paso 4: Para cada drone en este turno
        for drone_id, path in sorted(self.drone_paths.items()):
            if drone_id in delivered:
                continue  # Ya llegó, no reportar

Paso 5: Encontrar posición actual del drone
            current_node = None
            next_node = None

            for i, node in enumerate(path):
                if node.time == t:
                    current_node = node
                    if i + 1 < len(path):
                        next_node = path[i + 1]
                    break

Paso 6: Manejar casos especiales
            # Caso: Drone en vuelo hacia zona RESTRICTED
            if current_node is None:
                in_flight = self._is_in_flight_to_restricted(drone_id, t)
                if in_flight:
                    movements.append(f"D{drone_id}-{in_flight}")
                continue

            # Caso: Drone esperando (mismo nodo en t y t+1)
            if next_node and next_node.hub.name == current_node.hub.name:
                continue  # No reportar esperas

Paso 7: Generar movimiento
            if next_node:
                destination = next_node.hub.name

                if next_node.hub.zone == ZoneType.RESTRICTED:
                    # Formato especial para zonas restringidas
                    connection = self._get_connection_name(
                        current_node.hub.name, next_node.hub.name
                    )
                    movements.append(f"D{drone_id}-{connection}")
                else:
                    # Formato normal
                    movements.append(f"D{drone_id}-{destination}")

                # Marcar como entregado si llegó al END
                if next_node.hub.category == NodeCategory.END:
                    delivered.add(drone_id)

Paso 8: Añadir línea si hay movimientos
        if movements:
            output_lines.append(" ".join(movements))

Paso 9: Retornar resultado
    return output_lines

MÉTODO _is_in_flight_to_restricted(drone_id: int, current_time: int):
---------------------------------------------------------------------
Detecta si un drone está en tránsito hacia una zona RESTRICTED.

Las zonas RESTRICTED tardan 2 turnos. Durante el turno intermedio,
el drone no está en ningún nodo (está "en el aire").

    for i, node in enumerate(path):
        if i + 1 < len(path):
            next_node = path[i + 1]
            if (
                node.time < current_time
                and next_node.time > current_time
                and next_node.hub.zone == ZoneType.RESTRICTED
            ):
                return f"{node.hub.name}-{next_node.hub.name}"
    return None

MÉTODO print_simulation_output() -> None:
-----------------------------------------
Imprime el resultado final a stdout.

    output = self.get_simulation_output()
    for line in output:
        print(line)

================================================================================
7. ESTRUCTURAS DE DATOS CLAVE - RESUMEN
================================================================================

ESQUEMAS DE ENTRADA (src/schemas/):
-----------------------------------
SimulationMap
    └── nb_drones: int
    └── hubs: dict[str, Hub]
    └── connections: dict[str, dict[str, Connection]]

Hub
    └── name: str
    └── category: NodeCategory (START/END/INTERMEDIATE)
    └── zone: ZoneType (NORMAL/BLOCKED/RESTRICTED/PRIORITY)
    └── x, y: int (coordenadas)
    └── max_drones: int (capacidad)
    └── current_drones: int

Connection
    └── source: str
    └── target: str
    └── max_link_capacity: int
    └── current_drones: int

MODELOS DEL GRAFO TEMPORAL (src/solver/models.py):
--------------------------------------------------
TimeNode
    └── hub: Hub (referencia al hub físico)
    └── time: int (instante temporal)
    └── is_priority: bool
    └── is_end: bool
    └── current_drones: int
    └── can_enter() -> bool
    └── add_drone() -> None

TimeEdge
    └── source: TimeNode
    └── target: TimeNode
    └── duration: int (time_target - time_source)
    └── max_capacity: int
    └── is_traversable(tracker) -> bool
    └── use_edge(tracker) -> None

EdgeTracker
    └── edge_drones: dict[(TimeEdge, int), int]
    └── get_current_drones(edge, time) -> int
    └── add_drone(edge, time) -> None

GRAFO TEMPORAL (src/solver/time_graph.py):
------------------------------------------
TimeGraph
    └── max_time: int
    └── nodes: dict[(str, int), TimeNode]
    └── edges: list[TimeEdge]
    └── simulation: SimulationMap
    └── build_graph() -> None

SOLVER (src/solver/flow_solver.py):
-----------------------------------
FlowSolver
    └── time_graph: TimeGraph
    └── nb_drones: int
    └── tracker: EdgeTracker
    └── adjacency: dict[TimeNode, list[TimeEdge]]
    └── drone_paths: dict[int, list[TimeNode]]
    └── solve_all_drones() -> dict[int, list[TimeNode]]
    └── solve_for_drone(id, start) -> list[TimeNode]
    └── get_simulation_output() -> list[str]
    └── print_simulation_output() -> None

================================================================================
DIAGRAMA DE FLUJO COMPLETO
================================================================================

    ┌─────────────────────────────────────────────────────────────────┐
    │                    python main_solver.py map.txt                │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  1. PARSEO                                                      │
    │     FileParser.parse(map.txt)                                   │
    │     ├── DroneProcessor -> nb_drones                             │
    │     ├── HubProcessor -> hubs dict                               │
    │     └── ConnectionProcessor -> connections dict                 │
    │     Resultado: SimulationMap                                    │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  2. VALIDACIÓN                                                  │
    │     has_path_to_end(simulation)                                 │
    │     └── BFS: ¿Existe camino START → END?                        │
    │     Si no existe → ERROR y salir                                │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  3. ESTIMACIÓN TEMPORAL                                         │
    │     estimate_max_time(simulation)                               │
    │     ├── estimate_min_path_length() → BFS con pesos              │
    │     └── max_time = min_path + nb_drones + 5                     │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  4. BUCLE DE RESOLUCIÓN (solve_with_retry)                      │
    │                                                                 │
    │     ┌─────────────────────────────────────────────────────────┐ │
    │     │  4a. CONSTRUCCIÓN DEL GRAFO                             │ │
    │     │      TimeGraph(simulation, max_time)                    │ │
    │     │      build_graph()                                      │ │
    │     │      ├── Crear TimeNodes para cada (hub, t)             │ │
    │     │      ├── Crear TimeEdges de movimiento                  │ │
    │     │      └── Crear TimeEdges de espera                      │ │
    │     └─────────────────────────────────────────────────────────┘ │
    │                          │                                      │
    │                          ▼                                      │
    │     ┌─────────────────────────────────────────────────────────┐ │
    │     │  4b. RESOLUCIÓN                                         │ │
    │     │      FlowSolver(time_graph, nb_drones)                  │ │
    │     │      solve_all_drones()                                 │ │
    │     │                                                         │ │
    │     │      Para cada drone 1..N:                              │ │
    │     │      ├── solve_for_drone() → Dijkstra modificado        │ │
    │     │      │   ├── Heap con (turns, -priorities)              │ │
    │     │      │   ├── Verificar capacidad aristas (tracker)      │ │
    │     │      │   └── Verificar capacidad nodos (can_enter)      │ │
    │     │      └── _reserve_path() → Marcar recursos usados       │ │
    │     └─────────────────────────────────────────────────────────┘ │
    │                          │                                      │
    │                          ▼                                      │
    │     ┌─────────────────────────────────────────────────────────┐ │
    │     │  4c. VERIFICACIÓN                                       │ │
    │     │      ¿Todos los drones tienen ruta?                     │ │
    │     │      - SÍ → Continuar a paso 5                          │ │
    │     │      - NO → max_time += 3, repetir paso 4               │ │
    │     └─────────────────────────────────────────────────────────┘ │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  5. GENERACIÓN DE OUTPUT                                        │
    │     get_simulation_output()                                     │
    │     ├── Para cada turno t:                                      │
    │     │   ├── Para cada drone:                                    │
    │     │   │   ├── Encontrar posición en t                         │
    │     │   │   └── Generar "D<id>-<destino>"                       │
    │     │   └── Unir movimientos con espacios                       │
    │     └── Retornar lista de líneas                                │
    │                                                                 │
    │     print_simulation_output()                                   │
    │     └── Imprimir cada línea a stdout                            │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  OUTPUT FINAL                                                   │
    │  D1-waypoint1 D2-waypoint1 D3-waypoint1                         │
    │  D1-waypoint2 D2-waypoint2 D3-waypoint2                         │
    │  D1-end D2-waypoint3 D3-waypoint3                               │
    │  D2-end D3-end                                                  │
    └─────────────────────────────────────────────────────────────────┘

================================================================================
FIN DE LA DOCUMENTACIÓN
================================================================================
